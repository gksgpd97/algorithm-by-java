"""함수의 정의
def rec(n, r, c):
    print()
#2^n X 2^n 배열에서 (r,c)를 방문하는 순서를 반환하는 함수
"""

"""재귀식
4등분을 할 때 z 흐름대로 1234 구역을 나누면

N=2 -> 4X4 -> 0~15
1구역 -> 0<=r,c<2^N/2 -> 0<=r,c<2
2구역 -> 0<=r<2^N/2 | 2^N/2<=c<2^N
3구역 -> 2^N/2<=r<2^N | 0<=c<2^N/2
4구역 -> 2^N/2<=r,c<2^N

N=1일 때 정의 arr[[0,1],[2,3]]

N=2일 때 예시

2구역 (0,2) -> 1구역(0,0)을 참고
f(n-1,r,c-2^N/2) + 4 -> N=1일 때 f(1, 0, 0) -> 0

3구역 (2,0) -> 1구역(0,0)을 참고
f(n-1, r-2, c) + 4*2

4구역 (3,2) -> 1구역(1, 0)을 참고
f(n-1, r-2, c-2) + 4*3

N=3일 때 예시
2구역 (3,6) -> 1구역(3,2)를 참고 (예상 답 :30)
f(n-1, r, c-4(=2^3/2)) + 16(2^3) -> f(2,3,2) +4(2^2)*3 +16 
->  f(1, 1, 0) +12+16 -> 2+12+16 = 30 

1구역 (1,1) -> 1구역 (1,1) 참고 (예상 3)
f(n-1, r, c) -> f(2, 1, 1) -> f(1,1,1)->3

결론
N=1 arr[[0,1],[2,3]]
1구역 -> f(n-1, r, c)
2구역 -> f(n-1, r, c-2^N/2) + 2^N*2^N/4
3구역 -> f(n-1, r-2^N/2, c) +2^N*2^N/4*2
4구역 -> f(n-1, r-2^N/2, c-2^N/2) +2^N*2^N/4*3
종료 조건: N=1 -> arr[r][c] 
"""

def func(N, r, c):
    global base
    #종료 조건
    if (N==1):
        return (base[r][c])
    #1구역
    if (0<= r < (2**N)/2 and 0 <= c < (2**N)/2):
        return func(N-1, r, c)
    #2구역
    elif (0<=r<(2**N)/2 and (2**N)/2<=c<(2**N)):
        return func(N-1, r, int(c-(2**N)/2)) + (((2**N)*(2**N))/4)
    #3구역
    elif ((2**N)/2<=r<(2**N) and 0<=c<(2**N)/2):
        return func(N-1, int(r-(2**N)/2), c) + (((2**N)*(2**N))/4)*2
    #4구역
    else:
        return func(N-1, int(r-(2**N)/2), int(c-(2**N)/2)) + (((2**N)*(2**N))/4)*3            
        
N,r,c = map(int, input().rstrip().split(" "))

global base
base = [[0,1],[2,3]]
print(int(func(N,r,c)))
